import "lexer.lch"
import "parser.lch"
import "../utils.lch"

fn Parser_new(l: Lexer): Parser {
	return Parser { l, peeked: false }
}

fn Parser.peek(): Token {
	if !self.peeked {
		set self._token = self.l.next()
		set self.peeked = true
	}

	return self._token
}

fn Parser.take() {
	do assert(self.peeked, "took when not peeked")
	set self.peeked = false
}

fn Parser.next(): Token {
	let p = self.peek()
	do self.take()
	return p
}

fn Parser.is_eof(): bool {
	switch self.peek().kind {
		case _: TokenKind::EOF { return true }
		case { return false }
	}
	unreachable
}

fn Parser.guardkw(s: str): GuardResult {
	let t = self.peek()

	switch t.kind {
		case sy: TokenKind::Symbol {
			if sy._ == s {
				do self.take()
				return GuardResult { t, v: true }
			}
		}
	}

	return GuardResult { t, v: false }
}

fn Parser.guardident(s: str): str {
	let t = self.peek()
	switch t.kind {
		case id: TokenKind::Identifier { return id._ }
		case { return "" }
	}
	unreachable
}
