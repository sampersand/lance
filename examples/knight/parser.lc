//import "abort"
//externf abort: fn(str);
fn abort(msg: str) {
	do print(msg + "\n");
	do quit(1);
}
struct Parser {
	s: str,
	idx: num
}

fn new_parser(s: str): Parser {
	return Parser{ s: s, idx: 0 };
}

fn is_eof(p: Parser): bool {
	return length(p.s) == 0;
}


fn peek(p: Parser): str {
	if is_eof(p) {
		return '';
	}

	return p.s[0];
}

fn advance(p: Parser) {
	if is_eof(p) {
		do abort("Advanced after EOF");
	} else {
		set p.idx = p.idx + 1;
	}
}

fn contains(s: str, c: str): bool {
	let i = 0;

	while i < length(s) {
		if c == s[i] {
			return true;
		}

		set i = i + 1;
	}

	return false;
}

fn islower(c: str): bool {
	return (c == '_') || (('a' <= c) && (c <= 'z'));
}

fn isupper(c: str): bool {
	return ('A' <= c) && (c <= 'Z');
}

fn isspace(c: str): bool {
	return contains(" \t\n\r\f(){}[]:", c);
}

//fn parse() {

//}

fn main(_: [str]): num {
	let l = "A";
	if islower(l) {
		do print("yup\n");
	} else {
		do print("nope\n");
	}
	return 0;
}

fn _strip_whitespace(p: Parser) {
}
